---
substitutions:
  switch_name: Switch
  binary_sensor_name: Button
  # 120A clamp (3000:1): 1.143207411
  # 50A clamp (2400:1): 1.156612516
  # 50A Victron clamp (2000:1): 0.76
  scale_a_power: '1.156612516'
  scale_b_power: '1.156612516'
  # Consider calibrating CT clamps, measurements were closer to the stock Shelly EM firmware for me without calibration
  # See: https://community.home-assistant.io/t/anyone-using-shelly-em/149867

packages:
  common: !include ../common-esp8266.yaml
  meshmesh: !include ../common/meshmesh.yaml

i2c:
  sda: GPIO12
  scl: GPIO14

status_led:
  pin:
    number: GPIO0
    inverted: yes

switch:
  - platform: gpio
    id: switch_1
    name: ${switch_name}
    pin: GPIO15

sensor:
  - platform: ade7953_i2c
    # WARNING: Prevent overheating by setting this IRQ pin! - See https://esphome.io/components/sensor/ade7953.html
    irq_pin: GPIO13
    voltage:
      name: Voltage
      id: voltage
      filters:
        - or:
          - delta: 1%
          - throttle_average: 60s
    frequency:
      name: Frequency
      id: frequency
      filters:
          - throttle: 60s
    current_a:
      name: Phase 1 Current
      id: current_phase_1
      filters:
        - or:
          - delta: 10%
          - throttle_average: 15s
    current_b:
      name: Phase 2 Current
      id: current_phase_2
      filters:
        - or:
          - delta: 10%
          - throttle_average: 15s
    active_power_a:
      name: Phase 1 Power
      id: power_phase_1
      filters:
        - multiply: $scale_a_power
        - or:
          - delta: 10%
          - throttle_average: 15s
        # In case you don't want negative power values. I don't see why you wouldn't - this allows to measure returned power, for instance by PV panels.
        # Regarding the energy calculation with both forward and return energy, this may need further consideration.
        #- lambda: if (x <= 0.0) return 0; else return x * $scale_a_power;
    active_power_b:
      name: Phase 2 Power
      id: power_phase_2
      filters:
        - multiply: $scale_b_power
        - or:
          - delta: 10%
          - throttle_average: 15s
        #- lambda: if (x <= 0.0) return 0; else return x * $scale_b_power;
    apparent_power_a:
      name: Phase 1 Apparent Power
      id: apparent_power_phase_1
      filters:
        - multiply: $scale_a_power
        - or:
          - delta: 10%
          - throttle_average: 15s
    apparent_power_b:
      name: Phase 2 Apparent Power
      id: apparent_power_phase_2
      filters:
        - multiply: $scale_b_power
        - or:
          - delta: 10%
          - throttle_average: 15s
    power_factor_a:
      name: Phase 1 Power Factor
      id: power_factor_phase_1
      filters:
        - throttle_average: 15s
    power_factor_b:
      name: Phase 2 Power Factor
      id: power_factor_phase_2
      filters:
        - throttle_average: 15s
    reactive_power_a:
      name: Phase 1 Reactive Power
      id: reactive_power_phase_1
      filters:
        - multiply: $scale_a_power
        - or:
          - delta: 10%
          - throttle_average: 15s
    reactive_power_b:
      name: Phase 2 Reactive Power
      id: reactive_power_phase_2
      filters:
        - multiply: $scale_b_power
        - or:
          - delta: 10%
          - throttle_average: 15s
    # Short (internal) update interval while using the throttling settings in all sensors above (provides results close to the native Shellys)
    update_interval: 10s

  # Derived sensors
  - platform: template
    id: power_in_phase_2
    name: "Phase 2 Power In"
    lambda: |-
      return id(power_phase_2).state <= 0.0 ? 0.0 : id(power_phase_2).state;
    device_class: power
    state_class: measurement
    unit_of_measurement: W
    filters:
      - throttle: 15s

  - platform: template
    id: power_out_phase_2
    name: "Phase 2 Power Out"
    lambda: |-
      return id(power_phase_2).state >= 0.0 ? 0.0 : -id(power_phase_2).state;
    device_class: power
    state_class: measurement
    unit_of_measurement: W
    filters:
      - throttle: 15s

  - platform: total_daily_energy
    name: "Phase 2 Energy In"
    id: energy_phase_2
    power_id: power_in_phase_2
    filters:
      # Multiplication factor from W to kWh is 0.001
      - multiply: 0.001
      - throttle: 60s
    unit_of_measurement: kWh
    state_class: total_increasing
    device_class: energy

  - platform: total_daily_energy
    name: "Phase 2 Energy Out"
    id: energy_out_phase_2
    power_id: power_out_phase_2
    filters:
      # Multiplication factor from W to kWh is 0.001
      - multiply: 0.001
      - throttle: 60s
    unit_of_measurement: kWh
    state_class: total_increasing
    device_class: energy

  - platform: total_daily_energy
    name: Phase 1 Energy
    id: energy_phase_1
    power_id: power_phase_1
    filters:
      # Multiplication factor from W to kWh is 0.001
      - multiply: 0.001
      - throttle: 60s
    unit_of_measurement: kWh
    state_class: total_increasing
    device_class: energy

    # NTC Temperature
  - platform: ntc
    sensor: temp_resistance_reading
    name: "Temperature"
    calibration:
      b_constant: 3350
      reference_resistance: 10kOhm
      reference_temperature: 298.15K
  - platform: resistance
    id: temp_resistance_reading
    sensor: temp_analog_reading
    configuration: DOWNSTREAM
    # This value is a guess, based on the temperature values compared to native Shelly EM devices
    resistor: 100kOhm
  - platform: adc
    id: temp_analog_reading
    pin: A0

